# INTRO

[[exercises]]
name = "errors2"
path = "exercises/13_error_handling/errors2.rs"
mode = "test"
hint = """
One way to handle this is using a `match` statement on
`item_quantity.parse::<i32>()` where the cases are `Ok(something)` and
`Err(something)`.

This pattern is very common in Rust, though, so there's a `?` operator that
does pretty much what you would make that match statement do for you!

Take a look at this section of the 'Error Handling' chapter:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
and give it a try!"""

[[exercises]]
name = "errors3"
path = "exercises/13_error_handling/errors3.rs"
mode = "compile"
hint = """
If other functions can return a `Result`, why shouldn't `main`? It's a fairly
common convention to return something like `Result<(), ErrorType>` from your
main function.

The unit (`()`) type is there because nothing is really needed in terms of
positive results."""

[[exercises]]
name = "errors4"
path = "exercises/13_error_handling/errors4.rs"
mode = "test"
hint = """
`PositiveNonzeroInteger::new` is always creating a new instance and returning
an `Ok` result.

It should be doing some checking, returning an `Err` result if those checks
fail, and only returning an `Ok` result if those checks determine that
everything is... okay :)"""

[[exercises]]
name = "errors5"
path = "exercises/13_error_handling/errors5.rs"
mode = "compile"
hint = """
There are two different possible `Result` types produced within `main()`, which
are propagated using `?` operators. How do we declare a return type from
`main()` that allows both?

Under the hood, the `?` operator calls `From::from` on the error value to
convert it to a boxed trait object, a `Box<dyn error::Error>`. This boxed trait
object is polymorphic, and since all errors implement the `error::Error` trait,
we can capture lots of different errors in one "Box" object.

Check out this section of the book:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator

Read more about boxing errors:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html

Read more about using the `?` operator with boxed errors:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html
"""

[[exercises]]
name = "errors6"
path = "exercises/13_error_handling/errors6.rs"
mode = "test"
hint = """
This exercise uses a completed version of `PositiveNonzeroInteger` from
errors4.

Below the line that `TODO` asks you to change, there is an example of using
the `map_err()` method on a `Result` to transform one type of error into
another. Try using something similar on the `Result` from `parse()`. You
might use the `?` operator to return early from the function, or you might
use a `match` expression, or maybe there's another way!

You can create another function inside `impl ParsePosNonzeroError` to use
with `map_err()`.

Read more about `map_err()` in the `std::result` documentation:
https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"""

# Generics

[[exercises]]
name = "generics1"
path = "exercises/14_generics/generics1.rs"
mode = "compile"
hint = """
Vectors in Rust make use of generics to create dynamically sized arrays of any
type.

You need to tell the compiler what type we are pushing onto this vector."""

[[exercises]]
name = "generics2"
path = "exercises/14_generics/generics2.rs"
mode = "test"
hint = """
Currently we are wrapping only values of type `u32`.

Maybe we could update the explicit references to this data type somehow?

If you are still stuck https://doc.rust-lang.org/stable/book/ch10-01-syntax.html#in-method-definitions
"""

# TRAITS

[[exercises]]
name = "traits1"
path = "exercises/15_traits/traits1.rs"
mode = "test"
hint = """
A discussion about Traits in Rust can be found at:
https://doc.rust-lang.org/book/ch10-02-traits.html
"""

[[exercises]]
name = "traits2"
path = "exercises/15_traits/traits2.rs"
mode = "test"
hint = """
Notice how the trait takes ownership of `self`, and returns `Self`.

Try mutating the incoming string vector. Have a look at the tests to see
what the result should look like!

Vectors provide suitable methods for adding an element at the end. See
the documentation at: https://doc.rust-lang.org/std/vec/struct.Vec.html"""

[[exercises]]
name = "traits3"
path = "exercises/15_traits/traits3.rs"
mode = "test"
hint = """
Traits can have a default implementation for functions. Structs that implement
the trait can then use the default version of these functions if they choose not
to implement the function themselves.

See the documentation at: https://doc.rust-lang.org/book/ch10-02-traits.html#default-implementations
"""

[[exercises]]
name = "traits4"
path = "exercises/15_traits/traits4.rs"
mode = "test"
hint = """
Instead of using concrete types as parameters you can use traits. Try replacing
the '??' with 'impl <what goes here?>'

See the documentation at: https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters
"""

[[exercises]]
name = "traits5"
path = "exercises/15_traits/traits5.rs"
mode = "compile"
hint = """
To ensure a parameter implements multiple traits use the '+ syntax'. Try
replacing the '??' with 'impl <> + <>'.

See the documentation at: https://doc.rust-lang.org/book/ch10-02-traits.html#specifying-multiple-trait-bounds-with-the--syntax
"""

# QUIZ 3

[[exercises]]
name = "quiz3"
path = "exercises/quiz3.rs"
mode = "test"
hint = """
To find the best solution to this challenge you're going to need to think back
to your knowledge of traits, specifically 'Trait Bound Syntax'

You may also need this: `use std::fmt::Display;`."""

# LIFETIMES

[[exercises]]
name = "lifetimes1"
path = "exercises/16_lifetimes/lifetimes1.rs"
mode = "compile"
hint = """
Let the compiler guide you. Also take a look at the book if you need help:
https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"""

[[exercises]]
name = "lifetimes2"
path = "exercises/16_lifetimes/lifetimes2.rs"
mode = "compile"
hint = """
Remember that the generic lifetime `'a` will get the concrete lifetime that is
equal to the smaller of the lifetimes of `x` and `y`.

You can take at least two paths to achieve the desired result while keeping the
inner block:
1. Move the `string2` declaration to make it live as long as `string1` (how is
   `result` declared?)
2. Move `println!` into the inner block"""

[[exercises]]
name = "lifetimes3"
path = "exercises/16_lifetimes/lifetimes3.rs"
mode = "compile"
hint = """
If you use a lifetime annotation in a struct's fields, where else does it need
to be added?"""

# TESTS

[[exercises]]
name = "tests1"
path = "exercises/17_tests/tests1.rs"
mode = "test"
hint = """
You don't even need to write any code to test -- you can just test values and
run that, even though you wouldn't do that in real life. :)

`assert!` is a macro that needs an argument. Depending on the value of the
argument, `assert!` will do nothing (in which case the test will pass) or
`assert!` will panic (in which case the test will fail).

So try giving different values to `assert!` and see which ones compile, which
ones pass, and which ones fail :)"""

[[exercises]]
name = "tests2"
path = "exercises/17_tests/tests2.rs"
mode = "test"
hint = """
Like the previous exercise, you don't need to write any code to get this test
to compile and run.

`assert_eq!` is a macro that takes two arguments and compares them. Try giving
it two values that are equal! Try giving it two arguments that are different!
Try giving it two values that are of different types! Try switching which
argument comes first and which comes second!"""

[[exercises]]
name = "tests3"
path = "exercises/17_tests/tests3.rs"
mode = "test"
hint = """
You can call a function right where you're passing arguments to `assert!`. So
you could do something like `assert!(having_fun())`.

If you want to check that you indeed get `false`, you can negate the result of
what you're doing using `!`, like `assert!(!having_fun())`."""

[[exercises]]
name = "tests4"
path = "exercises/17_tests/tests4.rs"
mode = "test"
hint = """
We expect method `Rectangle::new()` to panic for negative values.

To handle that you need to add a special attribute to the test function.

You can refer to the docs:
https://doc.rust-lang.org/stable/book/ch11-01-writing-tests.html#checking-for-panics-with-should_panic"""

# STANDARD LIBRARY TYPES

[[exercises]]
name = "iterators1"
path = "exercises/18_iterators/iterators1.rs"
mode = "test"
hint = """
Step 1:

We need to apply something to the collection `my_fav_fruits` before we start to
go through it. What could that be? Take a look at the struct definition for a
vector for inspiration:
https://doc.rust-lang.org/std/vec/struct.Vec.html

Step 2 & step 3:

Very similar to the lines above and below. You've got this!

Step 4:

An iterator goes through all elements in a collection, but what if we've run
out of elements? What should we expect here? If you're stuck, take a look at
https://doc.rust-lang.org/std/iter/trait.Iterator.html for some ideas.
"""

[[exercises]]
name = "iterators2"
path = "exercises/18_iterators/iterators2.rs"
mode = "test"
hint = """
Step 1:

The variable `first` is a `char`. It needs to be capitalized and added to the
remaining characters in `c` in order to return the correct `String`.

The remaining characters in `c` can be viewed as a string slice using the
`as_str` method.

The documentation for `char` contains many useful methods.
https://doc.rust-lang.org/std/primitive.char.html

Step 2:

Create an iterator from the slice. Transform the iterated values by applying
the `capitalize_first` function. Remember to `collect` the iterator.

Step 3:

This is surprisingly similar to the previous solution. `collect` is very
powerful and very general. Rust just needs to know the desired type."""

[[exercises]]
name = "iterators3"
path = "exercises/18_iterators/iterators3.rs"
mode = "test"
hint = """
The `divide` function needs to return the correct error when even division is
not possible.

The `division_results` variable needs to be collected into a collection type.

The `result_with_list` function needs to return a single `Result` where the
success case is a vector of integers and the failure case is a `DivisionError`.

The `list_of_results` function needs to return a vector of results.

See https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect for
how the `FromIterator` trait is used in `collect()`. This trait is REALLY
powerful! It can make the solution to this exercise infinitely easier."""

[[exercises]]
name = "iterators4"
path = "exercises/18_iterators/iterators4.rs"
mode = "test"
hint = """
In an imperative language, you might write a `for` loop that updates a mutable
variable. Or, you might write code utilizing recursion and a match clause. In
Rust you can take another functional approach, computing the factorial
elegantly with ranges and iterators.

Hint 2: Check out the `fold` and `rfold` methods!"""

[[exercises]]
name = "iterators5"
path = "exercises/18_iterators/iterators5.rs"
mode = "test"
hint = """
The documentation for the `std::iter::Iterator` trait contains numerous methods
that would be helpful here.

The `collection` variable in `count_collection_iterator` is a slice of
`HashMap`s. It needs to be converted into an iterator in order to use the
iterator methods.

The `fold` method can be useful in the `count_collection_iterator` function.

For a further challenge, consult the documentation for `Iterator` to find
a different method that could make your code more compact than using `fold`."""

# SMART POINTERS

[[exercises]]
name = "box1"
path = "exercises/19_smart_pointers/box1.rs"
mode = "test"
hint = """
Step 1:

The compiler's message should help: since we cannot store the value of the
actual type when working with recursive types, we need to store a reference
(pointer) to its value.

We should, therefore, place our `List` inside a `Box`. More details in the book
here: https://doc.rust-lang.org/book/ch15-01-box.html#enabling-recursive-types-with-boxes

Step 2:

Creating an empty list should be fairly straightforward (hint: peek at the
assertions).

For a non-empty list keep in mind that we want to use our `Cons` "list builder".
Although the current list is one of integers (`i32`), feel free to change the
definition and try other types!
"""

[[exercises]]
name = "rc1"
path = "exercises/19_smart_pointers/rc1.rs"
mode = "test"
hint = """
This is a straightforward exercise to use the `Rc<T>` type. Each `Planet` has
ownership of the `Sun`, and uses `Rc::clone()` to increment the reference count
of the `Sun`.

After using `drop()` to move the `Planet`s out of scope individually, the
reference count goes down.

In the end the `Sun` only has one reference again, to itself.

See more at: https://doc.rust-lang.org/book/ch15-04-rc.html

* Unfortunately Pluto is no longer considered a planet :(
"""

[[exercises]]
name = "arc1"
path = "exercises/19_smart_pointers/arc1.rs"
mode = "compile"
hint = """
Make `shared_numbers` be an `Arc` from the numbers vector. Then, in order
to avoid creating a copy of `numbers`, you'll need to create `child_numbers`
inside the loop but still in the main thread.

`child_numbers` should be a clone of the `Arc` of the numbers instead of a
thread-local copy of the numbers.

This is a simple exercise if you understand the underlying concepts, but if this
is too much of a struggle, consider reading through all of Chapter 16 in the
book:
https://doc.rust-lang.org/stable/book/ch16-00-concurrency.html
"""

[[exercises]]
name = "cow1"
path = "exercises/19_smart_pointers/cow1.rs"
mode = "test"
hint = """
If `Cow` already owns the data it doesn't need to clone it when `to_mut()` is
called.

Check out https://doc.rust-lang.org/std/borrow/enum.Cow.html for documentation
on the `Cow` type.
"""

# THREADS

[[exercises]]
name = "threads1"
path = "exercises/20_threads/threads1.rs"
mode = "compile"
hint = """
`JoinHandle` is a struct that is returned from a spawned thread:
https://doc.rust-lang.org/std/thread/fn.spawn.html

A challenge with multi-threaded applications is that the main thread can
finish before the spawned threads are completed.
https://doc.rust-lang.org/book/ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles

Use the `JoinHandle`s to wait for each thread to finish and collect their
results.

https://doc.rust-lang.org/std/thread/struct.JoinHandle.html
"""

[[exercises]]
name = "threads2"
path = "exercises/20_threads/threads2.rs"
mode = "compile"
hint = """
`Arc` is an Atomic Reference Counted pointer that allows safe, shared access
to **immutable** data. But we want to *change* the number of `jobs_completed`
so we'll need to also use another type that will only allow one thread to
mutate the data at a time. Take a look at this section of the book:
https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct
and keep reading if you'd like more hints :)

Do you now have an `Arc` `Mutex` `JobStatus` at the beginning of main? Like:
```
let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));
```

Similar to the code in the example in the book that happens after the text
that says 'Sharing a Mutex<T> Between Multiple Threads'. If not, give that a
try! If you do and would like more hints, keep reading!!

Make sure neither of your threads are holding onto the lock of the mutex
while they are sleeping, since this will prevent the other thread from
being allowed to get the lock. Locks are automatically released when
they go out of scope.

If you've learned from the sample solutions, I encourage you to come
back to this exercise and try it again in a few days to reinforce
what you've learned :)"""

[[exercises]]
name = "threads3"
path = "exercises/20_threads/threads3.rs"
mode = "test"
hint = """
An alternate way to handle concurrency between threads is to use an `mpsc`
(multiple producer, single consumer) channel to communicate.

With both a sending end and a receiving end, it's possible to send values in
one thread and receive them in another.

Multiple producers are possible by using clone() to create a duplicate of the
original sending end.

See https://doc.rust-lang.org/book/ch16-02-message-passing.html for more info.
"""

# MACROS

[[exercises]]
name = "macros1"
path = "exercises/21_macros/macros1.rs"
mode = "compile"
hint = """
When you call a macro, you need to add something special compared to a
regular function call. If you're stuck, take a look at what's inside
`my_macro`."""

[[exercises]]
name = "macros2"
path = "exercises/21_macros/macros2.rs"
mode = "compile"
hint = """
Macros don't quite play by the same rules as the rest of Rust, in terms of
what's available where.

Unlike other things in Rust, the order of "where you define a macro" versus
"where you use it" actually matters."""

[[exercises]]
name = "macros3"
path = "exercises/21_macros/macros3.rs"
mode = "compile"
hint = """
In order to use a macro outside of its module, you need to do something
special to the module to lift the macro out into its parent.

The same trick also works on "extern crate" statements for crates that have
exported macros, if you've seen any of those around."""

[[exercises]]
name = "macros4"
path = "exercises/21_macros/macros4.rs"
mode = "compile"
hint = """
You only need to add a single character to make this compile.

The way macros are written, it wants to see something between each "macro arm",
so it can separate them.

That's all the macro exercises we have in here, but it's barely even scratching
the surface of what you can do with Rust's macros. For a more thorough
introduction, you can have a read through 'The Little Book of Rust Macros':
https://veykril.github.io/tlborm/"""

#  CLIPPY

[[exercises]]
name = "clippy1"
path = "exercises/22_clippy/clippy1.rs"
mode = "clippy"
hint = """
Rust stores the highest precision version of any long or infinite precision
mathematical constants in the Rust standard library:
https://doc.rust-lang.org/stable/std/f32/consts/index.html

We may be tempted to use our own approximations for certain mathematical
constants, but clippy recognizes those imprecise mathematical constants as a
source of potential error.

See the suggestions of the clippy warning in compile output and use the
appropriate replacement constant from `std::f32::consts`..."""

[[exercises]]
name = "clippy2"
path = "exercises/22_clippy/clippy2.rs"
mode = "clippy"
hint = """
`for` loops over `Option` values are more clearly expressed as an `if let`"""

[[exercises]]
name = "clippy3"
path = "exercises/22_clippy/clippy3.rs"
mode = "clippy"
hint = "No hints this time!"

# TYPE CONVERSIONS

[[exercises]]
name = "using_as"
path = "exercises/23_conversions/using_as.rs"
mode = "test"
hint = """
Use the `as` operator to cast one of the operands in the last line of the
`average` function into the expected return type."""

[[exercises]]
name = "from_into"
path = "exercises/23_conversions/from_into.rs"
mode = "test"
hint = """
Follow the steps provided right before the `From` implementation"""

[[exercises]]
name = "from_str"
path = "exercises/23_conversions/from_str.rs"
mode = "test"
hint = """
The implementation of `FromStr` should return an `Ok` with a `Person` object,
or an `Err` with an error if the string is not valid.

This is almost like the `from_into` exercise, but returning errors instead
of falling back to a default value.

Look at the test cases to see which error variants to return.

Another hint: You can use the `map_err` method of `Result` with a function
or a closure to wrap the error from `parse::<usize>`.

Yet another hint: If you would like to propagate errors by using the `?`
operator in your solution, you might want to look at
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html
"""

[[exercises]]
name = "try_from_into"
path = "exercises/23_conversions/try_from_into.rs"
mode = "test"
hint = """
Follow the steps provided right before the `TryFrom` implementation.
You can also use the example at
https://doc.rust-lang.org/std/convert/trait.TryFrom.html

Is there an implementation of `TryFrom` in the standard library that
can both do the required integer conversion and check the range of the input?

Another hint: Look at the test cases to see which error variants to return.

Yet another hint: You can use the `map_err` or `or` methods of `Result` to
convert errors.

Yet another hint: If you would like to propagate errors by using the `?`
operator in your solution, you might want to look at
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html

Challenge: Can you make the `TryFrom` implementations generic over many integer types?"""

[[exercises]]
name = "as_ref_mut"
path = "exercises/23_conversions/as_ref_mut.rs"
mode = "test"
hint = """
Add `AsRef<str>` or `AsMut<u32>` as a trait bound to the functions."""
